package flexepin

import (
	"fmt"
	"time"
	"encoding/json"
)

// Function tests to see if the API is active or offline.
// I'm not really sure what the point of this endpoint is. If the API is offline, then wouldn't this also not be accessible?
// Anyways, it is recommended by the docs and used in the ancient example code.
func (conf *Flexepin) Status() (bool, error) {
	reqUri := "/status"
	nonce := conf.TransactionIdGenerator()

	// The request type, URI (path), and a random nonce are hashed + signed by the secret key. Used in the Authentication header.
	payload := fmt.Sprintf("GET\n%s\n%s\n", reqUri, nonce)
	sig := getHmac(payload, conf.Secret)

	// Supply an empty byte slice if there is no request body (e.g. a GET request)
	res, err := authReq("GET", conf.RootUrl + reqUri, conf.SiteKey, sig, nonce, []byte(""))
	if err != nil {
		return false, err
	}

	var response StatusRes 
	err = json.Unmarshal([]byte(res), &response)
	if err != nil {
		return false, err
	}

	return response.Status == "alive", err
}

// Returns a ValidateRes, which includes further information on the status of the pin. It is not sufficent to rely on err being not nil
// A result of "0" (string) means the pin is ready to be redeemed. Any other result code means the pin is blocked, used, inactive, etc.
// Also returns a TXID, which may be useful to store to looking up later via the transactions API.
func (conf *Flexepin) Validate(pin string) (ValidateRes, error) {
	txid := conf.TransactionIdGenerator()
	reqUri := fmt.Sprintf("/voucher/validate/%s/%s/%s", pin, conf.TerminalId, txid)
	nonce := GetNonce()

	payload := fmt.Sprintf("GET\n%s\n%s\n", reqUri, nonce)
	sig := getHmac(payload, conf.Secret)

	res, err := authReq("GET", conf.RootUrl + reqUri, conf.SiteKey, sig, nonce, []byte(""))
	if err != nil {
		return ValidateRes{}, err
	}

	var response ValidateRes 
	err = json.Unmarshal([]byte(res), &response)
	if err != nil {
		return response, err
	}

	return response, err
}

// Actually redeem the voucher/pin. If result is equal to "0" (string), then it suceeded. It will likely be useful to save the
// TXID and or TXNO returned. The TXNO is a global incrementor on Flexepin's side, whereas the TXID is generated by us.
// Takes a Customer struct, which may include customer's unique Id, IP address and IP data (it is unspecified what is meant by IP data)
func (conf *Flexepin) Redeem(pin string, customer Customer) (RedeemRes, error) {
	txid := conf.TransactionIdGenerator()
	reqUri := fmt.Sprintf("/voucher/redeem/%s/%s/%s", pin, conf.TerminalId, txid)
	nonce := GetNonce()

	customerJson, err := json.Marshal(customer)
	if err != nil {
		return RedeemRes{}, err
	}

	payload := fmt.Sprintf("PUT\n%s\n%s\n%s", reqUri, nonce, customerJson)
	sig := getHmac(payload, conf.Secret)

	res, err := authReq("PUT", conf.RootUrl + reqUri, conf.SiteKey, sig, nonce, customerJson)
	if err != nil {
		return RedeemRes{}, err
	}

	var response RedeemRes
	err = json.Unmarshal([]byte(res), &response)
	if err != nil {
		return response, err
	}

	return response, err
}

// Get a single transaction by its merchant ID
func (conf *Flexepin) GetTransactionById(id string) (TransactionRes, error) {
	txid := conf.TransactionIdGenerator()
	reqUri := fmt.Sprintf("/trans/trans_id/%s/%s/%s", id, conf.TerminalId, txid)
	nonce := GetNonce()

	payload := fmt.Sprintf("GET\n%s\n%s\n", reqUri, nonce)
	sig := getHmac(payload, conf.Secret)

	res, err := authReq("GET", conf.RootUrl + reqUri, conf.SiteKey, sig, nonce, []byte(""))
	if err != nil {
		return TransactionRes{}, err
	}

	var response TransactionRes
	err = json.Unmarshal([]byte(res), &response)
	if err != nil {
		return response, err
	}

	return response, err
}

// Get a single transaction by its transaction number (set by flexepin)
func (conf *Flexepin) GetTransactionByNumber(no string) (TransactionRes, error) {
	txid := conf.TransactionIdGenerator()
	reqUri := fmt.Sprintf("/trans/trans_no/%s/%s/%s", no, conf.TerminalId, txid)
	nonce := GetNonce()

	payload := fmt.Sprintf("GET\n%s\n%s\n", reqUri, nonce)
	sig := getHmac(payload, conf.Secret)

	res, err := authReq("GET", conf.RootUrl + reqUri, conf.SiteKey, sig, nonce, []byte(""))
	if err != nil {
		return TransactionRes{}, err
	}

	var response TransactionRes
	err = json.Unmarshal([]byte(res), &response)
	if err != nil {
		return response, err
	}

	return response, err
}

// Get transactions between two dates. The API uses dates, not datetimes, so at minimum you are searching a 1 day window.
func (conf *Flexepin) GetTransactionsByDateRange(startDate time.Time, endDate time.Time) (TransactionsRes, error) {
	startDateStr := time.Now().Format("2006-01-02")
	endDateStr := time.Now().Format("2006-01-02")
	txid := conf.TransactionIdGenerator()
	reqUri := fmt.Sprintf("/trans/between/%s/%s/%s/%s", startDateStr, endDateStr, conf.TerminalId, txid)
	nonce := GetNonce()

	payload := fmt.Sprintf("GET\n%s\n%s\n", reqUri, nonce)
	sig := getHmac(payload, conf.Secret)

	res, err := authReq("GET", conf.RootUrl + reqUri, conf.SiteKey, sig, nonce, []byte(""))
	if err != nil {
		return TransactionsRes{}, err
	}

	var response TransactionsRes
	err = json.Unmarshal([]byte(res), &response)
	if err != nil {
		return response, err
	}

	return response, err
}

// Get a list of supported stores by two letter country code 
func (conf *Flexepin) GetStoresByCountry(country string) (StoreRes, error) {
	reqUri := fmt.Sprintf("/stores/%s", country)
	nonce := GetNonce()

	payload := fmt.Sprintf("GET\n%s\n%s\n", reqUri, nonce)
	sig := getHmac(payload, conf.Secret)

	res, err := authReq("GET", conf.RootUrl + reqUri, conf.SiteKey, sig, nonce, []byte(""))
	if err != nil {
		return StoreRes{}, err
	}

	var response StoreRes
	err = json.Unmarshal([]byte(res), &response)
	if err != nil {
		return response, err
	}

	return response, err
}

// Get a list of stores within X kilometers of the supplied longitude and latitude
func (conf *Flexepin) GetStoresByRange(lng string, lat string, kmRange string) (StoreRes, error) {
	reqUri := fmt.Sprintf("/stores/%s/%s/%s", lng, lat, kmRange)
	nonce := GetNonce()

	payload := fmt.Sprintf("GET\n%s\n%s\n", reqUri, nonce)
	sig := getHmac(payload, conf.Secret)

	res, err := authReq("GET", conf.RootUrl + reqUri, conf.SiteKey, sig, nonce, []byte(""))
	if err != nil {
		return StoreRes{}, err
	}

	var response StoreRes
	err = json.Unmarshal([]byte(res), &response)
	if err != nil {
		return response, err
	}

	return response, err
}

func New(siteKey string, secret string, terminalId string, rootUrl string, transactionIdGenerator func() string) *Flexepin {
	return &Flexepin{
		SiteKey: siteKey,
		Secret: secret,
		TerminalId: terminalId,
		RootUrl: rootUrl,
		TransactionIdGenerator: transactionIdGenerator,
	}
}